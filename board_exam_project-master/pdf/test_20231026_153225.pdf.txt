Number of pages: 46
Processed text from page 1:
컴퓨터 산술(9,10장)
성결대학교 컴퓨터공학부
최정열 교수
(passjay@sungkyul.ac.kr)
게으른 자여 네가 어느 때까지 누워 있겠느냐
네가 어느 때에 잠이 깨어 일어나겠느냐 좀더
자자, 좀더 졸자, 손을 모으고 좀더 누워있자
하면 네 빈궁이 강도 같이 오며 네 곤핍이
군사 같이 이르리라(잠언6:9-11)

Original text:
컴퓨터 산술(9,10장)
성결대학교 컴퓨터공학부
최정열 교수
(passjay@sungkyul.ac.kr)
게으른 자여 네가 어느 때까지 누워 있겠느냐
네가 어느 때에 잠이 깨어 일어나겠느냐 좀더
자자, 좀더 졸자, 손을 모으고 좀더 누워있자
하면 네 빈궁이 강도 같이 오며 네 곤핍이
군사 같이 이르리라(잠언6:9-11)

Processed text from page 2:
수업 목표
산술논리연산장치의 구성요소와 그 기능을 이해한다
10진수, 2진수, 16진수들 간의 변환을 할 수 있다
2의 보수 표현을 설명할 수 있다
정수 산술 연산(가감승제)을 할 수 있다
부동 소수점 표현을 설명할 수 있다
부동 소수점 산술 연산이 어떻게 수행되는지 설명할 수 있다
2

Original text:
수업 목표
산술논리연산장치의 구성요소와 그 기능을 이해한다
10진수, 2진수, 16진수들 간의 변환을 할 수 있다
2의 보수 표현을 설명할 수 있다
정수 산술 연산(가감승제)을 할 수 있다
부동 소수점 표현을 설명할 수 있다
부동 소수점 산술 연산이 어떻게 수행되는지 설명할 수 있다
2

Processed text from page 3:
목차
산술논리연산장치
정수 표현
정수의 산술 연산
부동소수점 표현
부동소수점의 산술 연산
논리 연산
3

Original text:
목차
산술논리연산장치
정수 표현
정수의 산술 연산
부동소수점 표현
부동소수점의 산술 연산
논리 연산
3

Processed text from page 4:
4
1. 산술논리연산장치(The Arithmetic and Logic Unit, ALU)
중앙처리장치(CPU)의 구성
 산술논리연산장치
- (Arithmetic & Logic Unit : ALU)
- 산술 및 논리 연산을 수행
 레지스터
 제어 장치
CPU의구성요소

Original text:
4
1. 산술논리연산장치(The Arithmetic and Logic Unit, ALU)
중앙처리장치(CPU)의 구성
 산술논리연산장치
- (Arithmetic & Logic Unit : ALU)
- 산술 및 논리 연산을 수행
 레지스터
 제어 장치
CPU의구성요소

Processed text from page 5:
5
ALU 내부 구성 요소
산술 연산장치
 +, -, ×, ÷등을 수행
논리 연산장치
 AND, OR, XOR, NOT 등을 수행
시프트 레지스터
 shift register
 비트들을 좌우측으로 이동
보수기(complementer)
 2진 데이터를 2의 보수로 변환
 음수를 만드는 역할
상태 레지스터(status register)
 연산 결과의 상태를 나타내는
플래그(flag)들을 저장
ALU의구성장치

Original text:
5
ALU 내부 구성 요소
산술 연산장치
 +, -, ×, ÷등을 수행
논리 연산장치
 AND, OR, XOR, NOT 등을 수행
시프트 레지스터
 shift register
 비트들을 좌우측으로 이동
보수기(complementer)
 2진 데이터를 2의 보수로 변환
 음수를 만드는 역할
상태 레지스터(status register)
 연산 결과의 상태를 나타내는
플래그(flag)들을 저장
ALU의구성장치

Processed text from page 6:
ALU의 연산 동작 예
ADD AC, B ; AC ← AC + B
 t1 : TEMP1 ← AC
 t2 : TEMP2 ← B
 t3 : AC ← TEMP1 + TEMP2
6
ALU의내부구조

Original text:
ALU의 연산 동작 예
ADD AC, B ; AC ← AC + B
 t1 : TEMP1 ← AC
 t2 : TEMP2 ← B
 t3 : AC ← TEMP1 + TEMP2
6
ALU의내부구조

Processed text from page 7:
7
2. 정수 표현
10진수의 개념
 0 ~ 9의 10가지의 기호를 이용하여 수를 표현
 10진수 (724)10의 분석 : 700+20+4
 10의 승수(10N)로 표현
- 10진수의 표시:  (724)10 = 7×102+2×101+4×100
2진수의 개념
 0과 1만을 가지고 수를 표현
 10진수의 관계는 2의 승수(2N)로 표현
- 예) (101101)2 = 1×25+0×24+1×23+1×22+0×21+1×20 = (45)10
16진수의 개념
 2진수를 4비트씩 나누어 16진수로 표현
 0~9, A, B, C, D, E, F의 기호를 사용
 16진수와 10진수의 관계는 16진수를 16의 승수(16N)로 표현
- 예) (F3)16 = 15×161 + 3×160 = (243)10

Original text:
7
2. 정수 표현
10진수의 개념
 0 ~ 9의 10가지의 기호를 이용하여 수를 표현
 10진수 (724)10의 분석 : 700+20+4
 10의 승수(10N)로 표현
- 10진수의 표시:  (724)10 = 7×102+2×101+4×100
2진수의 개념
 0과 1만을 가지고 수를 표현
 10진수의 관계는 2의 승수(2N)로 표현
- 예) (101101)2 = 1×25+0×24+1×23+1×22+0×21+1×20 = (45)10
16진수의 개념
 2진수를 4비트씩 나누어 16진수로 표현
 0~9, A, B, C, D, E, F의 기호를 사용
 16진수와 10진수의 관계는 16진수를 16의 승수(16N)로 표현
- 예) (F3)16 = 15×161 + 3×160 = (243)10

Processed text from page 8:
8
진법 변환
10진수를 2진수로의 변환
 연속적으로 2로 나눗셈을 수행하면서 얻어지는 나머지에 의해서 만들어진
다. 
 예) (41)10의 2진수로 변환
- 41을 2로 연속해서 나눗셈
- 생성된 나머지를 정렬
- (41)10 = (101001)2
2진수를 10진수로의 변환
 2진수를 2N로 표현
 예) (101001)2 = 1×25+0×24+1×23+0×22+0×21+1×20 = 32+8+1 = (41)10

Original text:
8
진법 변환
10진수를 2진수로의 변환
 연속적으로 2로 나눗셈을 수행하면서 얻어지는 나머지에 의해서 만들어진
다. 
 예) (41)10의 2진수로 변환
- 41을 2로 연속해서 나눗셈
- 생성된 나머지를 정렬
- (41)10 = (101001)2
2진수를 10진수로의 변환
 2진수를 2N로 표현
 예) (101001)2 = 1×25+0×24+1×23+0×22+0×21+1×20 = 32+8+1 = (41)10

Processed text from page 9:
9
 음수를 표현하기 위해서 단어의 가장 맨 좌측 비트를 부호 비트로 사용
 부호 비트를 사용한 음수의 표현 방법들
 부호 크기 표현(signed-magnitude representation)
 보수 표현(complement representation)
음수의 표현

Original text:
9
 음수를 표현하기 위해서 단어의 가장 맨 좌측 비트를 부호 비트로 사용
 부호 비트를 사용한 음수의 표현 방법들
 부호 크기 표현(signed-magnitude representation)
 보수 표현(complement representation)
음수의 표현

Processed text from page 10:
10
부호가 있는 n비트의 2진수에서, 최상위 비트는 부호 비트(signed bit)이
고 나머지 n-1개의 비트들은 수의 크기(magnitude)를 나타낸다
 예) +9 = 0 0001001                  -9 = 1 0001001
부호를 표현할 수 있는 가장 간단한 방법
덧셈과 뺄셈 연산을 수행하기 위해서는 부호 비트와 크기 부분을 별도
로 처리해야 한다
0(zero)의 표현이 2개 존재하므로 표현할 수 있는 수의 개수가 줄어든다
 0 00000000 = +0                     1 00000000 = -0
 즉, n비트 단어로 표현할 수 있는 수가 2n이 아니라 2n-1임
부호 크기 표현

Original text:
10
부호가 있는 n비트의 2진수에서, 최상위 비트는 부호 비트(signed bit)이
고 나머지 n-1개의 비트들은 수의 크기(magnitude)를 나타낸다
 예) +9 = 0 0001001                  -9 = 1 0001001
부호를 표현할 수 있는 가장 간단한 방법
덧셈과 뺄셈 연산을 수행하기 위해서는 부호 비트와 크기 부분을 별도
로 처리해야 한다
0(zero)의 표현이 2개 존재하므로 표현할 수 있는 수의 개수가 줄어든다
 0 00000000 = +0                     1 00000000 = -0
 즉, n비트 단어로 표현할 수 있는 수가 2n이 아니라 2n-1임
부호 크기 표현

Processed text from page 11:
11
보수 표현
2진수에서 1의 보수 표현: 모든 비트들을 반전시킨다
2진수에서 2의 보수 표현: 모든 비트들을 반전시키고, 결과에 1을 더한다
2의 보수로 표현된 2진수(양수)를 십진수로 변환(부호 비트 an-1 = 0)
2의 보수로 표현된 2진수(음수)를 십진수로 변환(부호 비트 an-1 = 1)
 또는, 먼저 양수로 변환하여 십진수를 구한 뒤, 그 결과값에 ‘-’ 부호를 붙인다
A = an-2 × 2n-2 + an-3 × 2n-3 + ... + a1 × 21 + a0 × 20
A =-2n-1 + (an-2 × 2n-2 + an-3 × 2n-3 + ... + a1 × 21 + a0 × 20)

Original text:
11
보수 표현
2진수에서 1의 보수 표현: 모든 비트들을 반전시킨다
2진수에서 2의 보수 표현: 모든 비트들을 반전시키고, 결과에 1을 더한다
2의 보수로 표현된 2진수(양수)를 십진수로 변환(부호 비트 an-1 = 0)
2의 보수로 표현된 2진수(음수)를 십진수로 변환(부호 비트 an-1 = 1)
 또는, 먼저 양수로 변환하여 십진수를 구한 뒤, 그 결과값에 ‘-’ 부호를 붙인다
A = an-2 × 2n-2 + an-3 × 2n-3 + ... + a1 × 21 + a0 × 20
A =-2n-1 + (an-2 × 2n-2 + an-3 × 2n-3 + ... + a1 × 21 + a0 × 20)

Processed text from page 12:
12
2의 보수로 표현된 n비트 데이터의 표현 할 수 있는 수의 범위
-2n-1 ≤ N ≤ 2n-1-1
비트에 따른 수의 범위와 최대값과 최소값의 표현
 8비트 2의 보수: -128 ≤ N ≤ +127
27–1 = 01111111 = +127
-27    = 10000000 = -128
 16비트 2의 보수: -32768 ≤ N ≤ +32767 
215-1 = 011111111 11111111 = +32767  
-215 = 100000000 00000000 = - 32768
수의 표현 범위

Original text:
12
2의 보수로 표현된 n비트 데이터의 표현 할 수 있는 수의 범위
-2n-1 ≤ N ≤ 2n-1-1
비트에 따른 수의 범위와 최대값과 최소값의 표현
 8비트 2의 보수: -128 ≤ N ≤ +127
27–1 = 01111111 = +127
-27    = 10000000 = -128
 16비트 2의 보수: -32768 ≤ N ≤ +32767 
215-1 = 011111111 11111111 = +32767  
-215 = 100000000 00000000 = - 32768
수의 표현 범위

Processed text from page 13:
예) 4비트 정수에 대한 다른 표현들
13

Original text:
예) 4비트 정수에 대한 다른 표현들
13

Processed text from page 14:
비트 확장(bit extension)
부호가 있는 데이터의 비트 수를 늘리는 연산
부호화-크기 표현
 부호 비트를 맨 좌측으로 이동시키고, 그 외의 비트들은 0으로 채운다
+18 =             00010010 (8비트)
+18 = 0000000000010010 (16비트) 
-18 =              00010010 (8비트)
-18 =  1000000000010010 (16비트)
2의 보수 표현
 확장된 상위 비트들을 부호 비트와 같은 값으로 채운다. 
+18 =             00010010 (8비트)
+18 = 0000000000010010 (16비트)
-18 =              11101110 (8비트)    
-18 = 1111111111101110 (16비트)
14

Original text:
비트 확장(bit extension)
부호가 있는 데이터의 비트 수를 늘리는 연산
부호화-크기 표현
 부호 비트를 맨 좌측으로 이동시키고, 그 외의 비트들은 0으로 채운다
+18 =             00010010 (8비트)
+18 = 0000000000010010 (16비트) 
-18 =              00010010 (8비트)
-18 =  1000000000010010 (16비트)
2의 보수 표현
 확장된 상위 비트들을 부호 비트와 같은 값으로 채운다. 
+18 =             00010010 (8비트)
+18 = 0000000000010010 (16비트)
-18 =              11101110 (8비트)    
-18 = 1111111111101110 (16비트)
14

Processed text from page 15:
15
음수화
덧셈 C = A + B
뺄셈 C = A - B
곱셈 C = A × B
나눗셈 C = A / B
3. 정수의 산술 연산

Original text:
15
음수화
덧셈 C = A + B
뺄셈 C = A - B
곱셈 C = A × B
나눗셈 C = A / B
3. 정수의 산술 연산

Processed text from page 16:
16
부호-크기 표현
 부호 비트를 반전시킨다
2의 보수를 사용
 예) 2의 보수를 이용하여 -19을 이진수로 표현
음수화(negation)
+19 : 00010011
1의보수 : 11101100
+             1
-19 : 11101101

Original text:
16
부호-크기 표현
 부호 비트를 반전시킨다
2의 보수를 사용
 예) 2의 보수를 이용하여 -19을 이진수로 표현
음수화(negation)
+19 : 00010011
1의보수 : 11101100
+             1
-19 : 11101101

Processed text from page 17:
2의 보수로 표현된 수들의 덧셈
두 수가 부호 없는 수인 것으로 간주하고 진행
 연산의 결과가 양수이면 정상적인 2진수로 표현된 양수를 얻음
 연산의 결과가 음수이면 2의 보수 형태의 음수를 얻음
17
결과값의 최상위 비트를
넘어가는 올림수 비트가
발생되면 무시한다
오버플로우: 어떤 덧셈에서
결과 값이 한 단어로 표현할
수 있는 범위를 초과

Original text:
2의 보수로 표현된 수들의 덧셈
두 수가 부호 없는 수인 것으로 간주하고 진행
 연산의 결과가 양수이면 정상적인 2진수로 표현된 양수를 얻음
 연산의 결과가 음수이면 2의 보수 형태의 음수를 얻음
17
결과값의 최상위 비트를
넘어가는 올림수 비트가
발생되면 무시한다
오버플로우: 어떤 덧셈에서
결과 값이 한 단어로 표현할
수 있는 범위를 초과

Processed text from page 18:
2의 보수로 표현된 수들의 뺄셈
어떤 수(피감수: minuend)
에서 다른 수(감수: 
subtrahend)를 빼기 위해
서는 감수의 보수를
취한 뒤 그것을 피감수
와 더한다
18

Original text:
2의 보수로 표현된 수들의 뺄셈
어떤 수(피감수: minuend)
에서 다른 수(감수: 
subtrahend)를 빼기 위해
서는 감수의 보수를
취한 뒤 그것을 피감수
와 더한다
18

Processed text from page 19:
2의 보수 정수들의 기하학적 표현
19

Original text:
2의 보수 정수들의 기하학적 표현
19

Processed text from page 20:
덧셈/뺄셈 하드웨어 블록 다이어그램
20

Original text:
덧셈/뺄셈 하드웨어 블록 다이어그램
20

Processed text from page 21:
곱셈
곱하여 지는 수를 피승수(multiplicand, M), 곱하는 수를 승수(multiplier, Q) 
부호가 없는 경우의 곱셈의 예
 4비트의 두 수가 서로 곱셈을 수행하면, 2배인 8비트의 길이의 결과를 출력
21

Original text:
곱셈
곱하여 지는 수를 피승수(multiplicand, M), 곱하는 수를 승수(multiplier, Q) 
부호가 없는 경우의 곱셈의 예
 4비트의 두 수가 서로 곱셈을 수행하면, 2배인 8비트의 길이의 결과를 출력
21

Processed text from page 22:
22
계산 예
부호 없는 2진 곱셈을 위한 하드웨어 구현
M
Q

Original text:
22
계산 예
부호 없는 2진 곱셈을 위한 하드웨어 구현
M
Q

Processed text from page 23:
부호없는 2진 곱셈의 흐름도
23

Original text:
부호없는 2진 곱셈의 흐름도
23

Processed text from page 24:
부호있는 두 수의 곱셈: Booth 알고리즘
승수와 피승수를 Q와 M 레지스터에 저장
 Q 레지스터의 LSB인 Q0 오른쪽에 Q-1 라는 한 비트 레지스터 추가
 Q0 와 Q-1 가 같으면: A, Q, Q-1 레지스터의 모든 비트를 우측으로 한 비트씩 산
술시프트
 Q0 와 Q-1 가 0 1 이면: 피승수를 A에 더한다 & 우측 산술시프트
 Q0 와 Q-1 가 1 0 이면: A로부터 피승수를 뺀다 & 우측 산술시프트
24결과

Original text:
부호있는 두 수의 곱셈: Booth 알고리즘
승수와 피승수를 Q와 M 레지스터에 저장
 Q 레지스터의 LSB인 Q0 오른쪽에 Q-1 라는 한 비트 레지스터 추가
 Q0 와 Q-1 가 같으면: A, Q, Q-1 레지스터의 모든 비트를 우측으로 한 비트씩 산
술시프트
 Q0 와 Q-1 가 0 1 이면: 피승수를 A에 더한다 & 우측 산술시프트
 Q0 와 Q-1 가 1 0 이면: A로부터 피승수를 뺀다 & 우측 산술시프트
24결과

Processed text from page 25:
25
Booth 알고리즘을 사용한 예

Original text:
25
Booth 알고리즘을 사용한 예

Processed text from page 26:
나눗셈
26
몫
제수(M) 피제수(Q)
부호 없는 2진 나눗셈을 위한 흐름도
부호 없는 2진 정수의 나눗셈 예

Original text:
나눗셈
26
몫
제수(M) 피제수(Q)
부호 없는 2진 나눗셈을 위한 흐름도
부호 없는 2진 정수의 나눗셈 예

Processed text from page 27:
27
2의 보수 나눗셈 예(7/3)
나머지 몫

Original text:
27
2의 보수 나눗셈 예(7/3)
나머지 몫

Processed text from page 28:
4. 부동소수점 표현
고정소수점(fixed-point) 표현 방식
1010.1010 = 23 + 21 +2-1 + 2-3 = 10.625
 매우 큰 수 및 매우 작은 수의 표현이 불가능
부동소수점(floating-point) 표현
 과학적 표기의 지수(exponent)를 사용하여 소수점의 위치를 이동시킬 수 있는
표현 방법
 표현의 범위가 확대
 예) 십진수에 대한 부동소수점 표현
176,000 = 1.76 × 105 176,000 = 17.6 × 104
0.000176 = 1.76 × 10-4 0.000176 = 17.6 × 10-5
28

Original text:
4. 부동소수점 표현
고정소수점(fixed-point) 표현 방식
1010.1010 = 23 + 21 +2-1 + 2-3 = 10.625
 매우 큰 수 및 매우 작은 수의 표현이 불가능
부동소수점(floating-point) 표현
 과학적 표기의 지수(exponent)를 사용하여 소수점의 위치를 이동시킬 수 있는
표현 방법
 표현의 범위가 확대
 예) 십진수에 대한 부동소수점 표현
176,000 = 1.76 × 105 176,000 = 17.6 × 104
0.000176 = 1.76 × 10-4 0.000176 = 17.6 × 10-5
28

Processed text from page 29:
부동소수점 수의 표현법
± S × B ± E
 부호(sign), S: 가수(significand), B: 기수(base), E: 지수(exponent)
29
전형적인 32비트 부동소수점 형식

Original text:
부동소수점 수의 표현법
± S × B ± E
 부호(sign), S: 가수(significand), B: 기수(base), E: 지수(exponent)
29
전형적인 32비트 부동소수점 형식

Processed text from page 30:
정규화된 표현
지수를 이용하는 부동소수점의 수는 지수의 값에 따라 동일한 수에 대
한 부동소수점 표현이 여러 가지가 존재
0.1001 x 25 100.1 x 22 0.01001 x 26
부동소수점의 수를 통일되게 표현하는 방법
± 1.bbb...b × 2E
 예) 정규화된 표현의 단일 정밀도 부동소수점의 수 배열
1.001 × 24
- 부호 비트 = 0(양수)
- 지수(E) = 00000100 
- 가수(S) = 0010 0000 0000 0000 0000 000
30
31 30                                      23 22                                                                     0
0 00000100 0010  0000  0000  0000  0000  000

Original text:
정규화된 표현
지수를 이용하는 부동소수점의 수는 지수의 값에 따라 동일한 수에 대
한 부동소수점 표현이 여러 가지가 존재
0.1001 x 25 100.1 x 22 0.01001 x 26
부동소수점의 수를 통일되게 표현하는 방법
± 1.bbb...b × 2E
 예) 정규화된 표현의 단일 정밀도 부동소수점의 수 배열
1.001 × 24
- 부호 비트 = 0(양수)
- 지수(E) = 00000100 
- 가수(S) = 0010 0000 0000 0000 0000 000
30
31 30                                      23 22                                                                     0
0 00000100 0010  0000  0000  0000  0000  000

Processed text from page 31:
가수
 정규화된 표현에서 가수의 맨 좌측 비트는 항상 1로 정해져 있으므로 가수
필드에 저장할 필요가 없다
 23비트를 이용하여 [1,2) 사이의 값을 가지는 24-비트 가수를 저장
기수
 기수는 묵시적이며 모든 수에 동일하므로 저장할 필요가 없다
지수(바이어스된 표현)
 지수는 부호를 가지므로 이에 대한 표현이 필요하다
 바이어스된 표현(2K-1)을 사용하여 음수가 아닌 부동소수점수의 크기를 비
교하기 위해서 정수로 취급될 수 있다
 바이어스된 값은 원래의 지수 비트 값에서 바이어스 값을 더해준다
 예) 지수값: (4)10 = (00000100)2
- 127로 바이어스된 지수값: 00000100 + 01111111 = 10000011
31

Original text:
가수
 정규화된 표현에서 가수의 맨 좌측 비트는 항상 1로 정해져 있으므로 가수
필드에 저장할 필요가 없다
 23비트를 이용하여 [1,2) 사이의 값을 가지는 24-비트 가수를 저장
기수
 기수는 묵시적이며 모든 수에 동일하므로 저장할 필요가 없다
지수(바이어스된 표현)
 지수는 부호를 가지므로 이에 대한 표현이 필요하다
 바이어스된 표현(2K-1)을 사용하여 음수가 아닌 부동소수점수의 크기를 비
교하기 위해서 정수로 취급될 수 있다
 바이어스된 값은 원래의 지수 비트 값에서 바이어스 값을 더해준다
 예) 지수값: (4)10 = (00000100)2
- 127로 바이어스된 지수값: 00000100 + 01111111 = 10000011
31

Processed text from page 32:
예) 10진수 -13.625를 32비트 부동소수점 형식으로 표현하면?
32

Original text:
예) 10진수 -13.625를 32비트 부동소수점 형식으로 표현하면?
32

Processed text from page 33:
예) 32비트 부동소수점으로 표현된 아래 수에 대한 10진수는?
33
0 10000011 101 0000 0000 0000 0000 0000

Original text:
예) 32비트 부동소수점으로 표현된 아래 수에 대한 10진수는?
33
0 10000011 101 0000 0000 0000 0000 0000

Processed text from page 34:
전형적인 32-비트 형식으로 표현 가능한 수의 범위
정수: -231~231-1 (232가지의 수를 표현)
부동소수점수: -(2-2-23)x2128~-2-127, 2-127~(2-2-23)x2128
34

Original text:
전형적인 32-비트 형식으로 표현 가능한 수의 범위
정수: -231~231-1 (232가지의 수를 표현)
부동소수점수: -(2-2-23)x2128~-2-127, 2-127~(2-2-23)x2128
34

Processed text from page 35:
부동소수점의 밀도
필드에 비트할당 문제
 표현하는 수의 범위와 정밀도를 결정
 지수(E) 필드의 비트 수가 늘어나면, 소수점을 이동시키는 범위가 커져서 표
현 가능한 수의 범위가 확장
 가수(S) 필드의 비트 수가 늘어나면, 이진수로 표현할 수 있는 수가 많아져서
정밀도(precision)가 증가
35

Original text:
부동소수점의 밀도
필드에 비트할당 문제
 표현하는 수의 범위와 정밀도를 결정
 지수(E) 필드의 비트 수가 늘어나면, 소수점을 이동시키는 범위가 커져서 표
현 가능한 수의 범위가 확장
 가수(S) 필드의 비트 수가 늘어나면, 이진수로 표현할 수 있는 수가 많아져서
정밀도(precision)가 증가
35

Processed text from page 36:
IEEE 754 formats
 지수부(2k-1 바이어스된 지수로 저장) 
- 지수부가 0 & 부호비트가 0이면: 0
- 지수부가 0 & , 부호비트가 1이면: -0 
• 표현할 수 있는 가장 작은 수보다 더 작은 0이 아닌 수
- 지수부가 제일 큰 값 & 부호비트가 0/1 = ∞/-∞
• 표현할 수 있는 수의 범위를 벗어남
36

Original text:
IEEE 754 formats
 지수부(2k-1 바이어스된 지수로 저장) 
- 지수부가 0 & 부호비트가 0이면: 0
- 지수부가 0 & , 부호비트가 1이면: -0 
• 표현할 수 있는 가장 작은 수보다 더 작은 0이 아닌 수
- 지수부가 제일 큰 값 & 부호비트가 0/1 = ∞/-∞
• 표현할 수 있는 수의 범위를 벗어남
36

Processed text from page 37:
5. 부동소수점의 산술 연산
가수와 지수의 연산을 분리해서 수행
덧셈과 뺄셈
 지수를 같은 값으로 조정한 후, 가수들에 대하여 덧셈과 뺄셈을 수행
곱셈과 나눗셈
 가수끼리는 곱셈과 나눗셈을 수행
 지수의 연산에서는 곱셈의 경우는 덧셈을 수행하고 나눗셈의 경우에는 뺄셈
을 한다
37

Original text:
5. 부동소수점의 산술 연산
가수와 지수의 연산을 분리해서 수행
덧셈과 뺄셈
 지수를 같은 값으로 조정한 후, 가수들에 대하여 덧셈과 뺄셈을 수행
곱셈과 나눗셈
 가수끼리는 곱셈과 나눗셈을 수행
 지수의 연산에서는 곱셈의 경우는 덧셈을 수행하고 나눗셈의 경우에는 뺄셈
을 한다
37

Processed text from page 38:
부동소수점 수들의 연산 예
38

Original text:
부동소수점 수들의 연산 예
38

Processed text from page 39:
39
1. 0인지 검사한다
2. 두 수의 지수들을 같아지도록 가수의 자리수를 조정한다
3. 가수들 간에 덧셈/뺄셈을 수행
 가수들의 부호를 고려해 더해진다
4. 결과를 정규화한다(normalization)
 가장 왼쪽 비트가 0이 아닐 때까지 좌측으로 쉬프트시킨다
예) 이진수의 부동소수점 수의 덧셈
부동소수점 수의 덧셈과 뺄셈
지수조정
1.110010 × 22 ⇒ 0.111001 × 23
+1.111011 × 23 + 1.111011 × 23 정규화
10.010100 × 23 ⇒ 1.00101 × 24

Original text:
39
1. 0인지 검사한다
2. 두 수의 지수들을 같아지도록 가수의 자리수를 조정한다
3. 가수들 간에 덧셈/뺄셈을 수행
 가수들의 부호를 고려해 더해진다
4. 결과를 정규화한다(normalization)
 가장 왼쪽 비트가 0이 아닐 때까지 좌측으로 쉬프트시킨다
예) 이진수의 부동소수점 수의 덧셈
부동소수점 수의 덧셈과 뺄셈
지수조정
1.110010 × 22 ⇒ 0.111001 × 23
+1.111011 × 23 + 1.111011 × 23 정규화
10.010100 × 23 ⇒ 1.00101 × 24

Processed text from page 40:
40
부동소수점 덧셈과 뺄셈 연산 흐름도(Z = X ± Y)

Original text:
40
부동소수점 덧셈과 뺄셈 연산 흐름도(Z = X ± Y)

Processed text from page 41:
41
가수끼리는 곱셈 연산을
수행하고 지수끼리는 덧
셈을 수행
부동소수점 수의 곱셈
부동소수점 곱셈 (Z  X x Y)

Original text:
41
가수끼리는 곱셈 연산을
수행하고 지수끼리는 덧
셈을 수행
부동소수점 수의 곱셈
부동소수점 곱셈 (Z  X x Y)

Processed text from page 42:
42
가수부분은 나눗셈 연산
을 수행하고, 지수부분은
뺄셈 연산 수행
부동소수점 수의 나눗셈
부동소수점 나눗셈 (Z  X / Y)

Original text:
42
가수부분은 나눗셈 연산
을 수행하고, 지수부분은
뺄셈 연산 수행
부동소수점 수의 나눗셈
부동소수점 나눗셈 (Z  X / Y)

Processed text from page 43:
43
마스크(mask) 연산
 원하는 비트들을 선택적으로 clear하는 데 사용하는 연산
 A 레지스터의 상위 4비트를 0으로 clear하는 경우의 예
6. 논리 연산
A = 1 0 1 1  0 1 0 1 (연산전)
B = 0 0 0 0  1 1 1 1 마스크 (AND)연산
A = 0 0 0 0  0 1 0 1 (연산후)

Original text:
43
마스크(mask) 연산
 원하는 비트들을 선택적으로 clear하는 데 사용하는 연산
 A 레지스터의 상위 4비트를 0으로 clear하는 경우의 예
6. 논리 연산
A = 1 0 1 1  0 1 0 1 (연산전)
B = 0 0 0 0  1 1 1 1 마스크 (AND)연산
A = 0 0 0 0  0 1 0 1 (연산후)

Processed text from page 44:
44
두 데이터를 비교하는 연산으로 대응되는 비트들의 값이 같으면 해당
비트를 0으로 세트하고, 서로 다르면 해당 비트를 1로 세트
모든 비트들이 같은 경우,  Z 플래그(zero 플래그)를 1로 세트
비교(compare) 연산
A = 1 1 1 0  0 0 0 1 (연산전)
B = 0 1 0 1  1 0 0 1 비교(XOR)연산
A = 1 0 1 1  1 0 0 0 (연산후)

Original text:
44
두 데이터를 비교하는 연산으로 대응되는 비트들의 값이 같으면 해당
비트를 0으로 세트하고, 서로 다르면 해당 비트를 1로 세트
모든 비트들이 같은 경우,  Z 플래그(zero 플래그)를 1로 세트
비교(compare) 연산
A = 1 1 1 0  0 0 0 1 (연산전)
B = 0 1 0 1  1 0 0 1 비교(XOR)연산
A = 1 0 1 1  1 0 0 0 (연산후)

Processed text from page 45:
45
쉬프트 과정에서 부호 비트는 유지하고, 수의 크기를 나타내는 비트들
만 쉬프트한다. 
산술적 좌측-쉬프트
 D4 (불변), D3 ← D2, D2 ← D1, D1 ← 0
산술적 우측-쉬프트
 D4 (불변), D4 → D3 , D3 → D2, D2 → D1 
예) 
A = 1 0 1 0 1 1 1 0 ; 초기 상태
1 1 0 1 1 1 0 0 ;  A의 산술적 좌측-쉬프트 결과
1 1 0 1 0 1 1 1 ; A의 산술적 우측-쉬프트 결과
산술적 쉬프트(arithmetic shift)

Original text:
45
쉬프트 과정에서 부호 비트는 유지하고, 수의 크기를 나타내는 비트들
만 쉬프트한다. 
산술적 좌측-쉬프트
 D4 (불변), D3 ← D2, D2 ← D1, D1 ← 0
산술적 우측-쉬프트
 D4 (불변), D4 → D3 , D3 → D2, D2 → D1 
예) 
A = 1 0 1 0 1 1 1 0 ; 초기 상태
1 1 0 1 1 1 0 0 ;  A의 산술적 좌측-쉬프트 결과
1 1 0 1 0 1 1 1 ; A의 산술적 우측-쉬프트 결과
산술적 쉬프트(arithmetic shift)

Processed text from page 46:
46
수고하고 무거운 짐 진 자들아
다 내게로 오라 내가 너희를
쉬게 하리라(마태복음11:28)

Original text:
46
수고하고 무거운 짐 진 자들아
다 내게로 오라 내가 너희를
쉬게 하리라(마태복음11:28)

